# DesignModelNotes



## **单一职责原则**

- **单一职责原则（SRP）** 是最简单的面向对象原则，它用于控制类的粒度大小。
  - 一个对象应该只包含单一的职责，并且该职责被完全地封装在一个类中。
- **开闭原则** 软件实体应该对扩展开放，对修改关闭。
  - 对扩展开放是针对提供方来说，对修改关闭是针对调用方
- **里氏替换原则**：所有引用基类的地方必须能透明的使用其子类的对象。简单来说就是，子类可以扩展父类的功能，但是不能修改父类的功能，
  - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
  - 子类可以增加自己特有的方法。
  - 当子类方法重载父类方法时，方法的前置条件（方法的输入/入参）要比父类的输入参数更宽松。
  - 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更加严格或一样。
- **依赖倒转原则**：高层模块不应该依赖底层模块，他们都应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象。
- **接口隔离原则**：客户端不应依赖他不需要的的接口。
- **合成复用原则**：优先使用对象组合，而不是通过继承来达到复用目的。
- **迪米特法则**：每个软件单位对其他单位都只有最少知识，而且局限于那些与本单位密切相关的软件单位。



--

## **设计模式（创建型）**

1. **工厂方法模式**：
2. **抽象工厂模式**：
3. **建造者模式**：
4. **单例模式**：
5. **原型模式**
   1. 浅拷贝：对于类中的基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象。
   2. 深拷贝：无论是基本数据类型还是i引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。

## **设计模式（结构型）**

1. **类/对象适配器模式**
2. **桥接模式**
3. **组合模式**
4. **装饰模式**
5. **代理模式****  ✨
6. **外观模式**
7. **享元模式**

## **设计模式（行为型）**

1. **解释器模式**
2. 模版方法模式
3. 责任链模式
4. 命令模式
5. 迭代器模式
6. 中介者模式
7. 备忘录模式
8. 观察者模式
9. 状态模式
10. 策略模式
11. 访问者模式
